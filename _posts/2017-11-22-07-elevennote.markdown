---
layout: post
title: Приложение для ведения заметок
categories: python golang web практики
---

В этой работе вы напишите простое приложение для ведения заметок, покрывая каждую часть приложения тестами. Ваше приложение будет работать в нескольких докер-контейнерах (о которых вы вскоре узнаете). И в конце разработаете API и swagger-схему для этого приложения.

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Эта работа основана на <a href="https://github.com/sixfeetup/ElevenNote">замечательном руководстве</a> по Django от компании Six Feet Up.</p>
</div>

Как обычно создайте новую ветку разработки, папку для вашего проекта `elevennote` и виртуальное окружение с именем `elevennote-env`, в котором установите следующие пакеты:

```bash
(elevennote-env) $ pip install Django==2.0.1
(elevennote-env) $ pip install psycopg2==2.7.3.2
(elevennote-env) $ pip install python-decouple==3.1
(elevennote-env) $ pip install uWSGI==2.0.15
```

Можете запустить команду `pip freeze` для просмотра установленных пакетов:

```python
(elevennote-env) $ pip freeze
Django==2.0.1
psycopg2==2.7.3.2
uWSGI==2.0.15
python-decouple==3.1
pytz==2017.2
```

Все зависимости будем хранить в отдельном манифесте:

```bash
(elevennote-env) $ mkdir requirements
(elevennote-env) $ pip freeze > requirements/base.txt
(elevennote-env) $ echo "-r base.txt" >> requirements/dev.txt
(elevennote-env) $ echo "-r base.txt" >> requirements/prod.txt
```

Теперь создадим новый проект с помощью команды `django-admin` (исходники проекта будем хранить в папке `src`). Обратите внимание, что имя проекта `config`, а все файлы проекта будут созданы в текущей рабочей директории (на что указывает `.`):

```bash
(elevennote-env) $ mkdir src && cd $_
(elevennote-env) $ django-admin startproject config .
(elevennote-env) $ ls
config manage.py
(elevennote-env) $ cd ..
```

В результате вы должны получить следующую структуру проекта:
```bash
elevennote/
├── requirements
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
└── src
    ├── config
    │   ├── __init__.py
    │   ├── settings.py
    │   ├── urls.py
    │   └── wsgi.py
    └── manage.py
```

Можете проверить, что проект запускается командой `python manage.py runserver` (если после запуска была создана БД `db.sqlite3`, а какие-то файлы закешированы `__pycache__`, то можете смело их удалить и добавить в `.gitignore`).

Конфигурацию нашего проекта разделим на:
- `base.py` - общая конфигурация для всех развертываний проекта;
- `local.py` - конфигурация, которая используется при разработке (включенный режим откладки, дополнительные пакеты для разработки, например, `django-debug-toolbar`);
- `production.py` - настройки, которые используются для production-сервера.

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Если по каким-либо причинам приложение <code>tree</code> не найдено, <a href="https://superuser.com/a/359727" target="_blank">здесь</a> вы найдете информацию по его установке.</p>
</div>

```bash
(elevennote-env) $ mkdir src/config/settings
(elevennote-env) $ mv src/config/settings.py src/config/settings/base.py
(elevennote-env) $ touch src/config/settings/__init__.py
(elevennote-env) $ touch src/config/settings/local.py
(elevennote-env) $ touch src/config/settings/production.py
(elevennote-env) $ touch src/config/settings/settings.ini
(elevennote-env) $ tree src/config
src/config
├── __init__.py
├── settings
│   ├── __init__.py
│   ├── base.py
│   ├── local.py
│   ├── production.py
│   └── settings.ini
├── urls.py
└── wsgi.py
```

Содержимое файла `config/settings/base.py`:

```python
import os
from decouple import config


def root(*dirs):
    base_dir = os.path.join(os.path.dirname(__file__), '..', '..')
    return os.path.abspath(os.path.join(base_dir, *dirs))


BASE_DIR = root()

SECRET_KEY = config('SECRET_KEY')

INSTALLED_APPS = [
    # ...
]

MIDDLEWARE = [
    # ...
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    # ...
]

WSGI_APPLICATION = 'config.wsgi.application'

AUTH_PASSWORD_VALIDATORS = [
    # ...
]

STATIC_URL = '/static/'

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True
```

Содержимое файла `configs/settings/local.py`:

```python
from .base import *

DEBUG = True

INSTALLED_APPS += [
    'django.contrib.postgres',
]

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
        'PORT': config('DB_PORT', cast=int),
    }
}
```

В `config/settings/settings.ini` укажите секретный ключ для Django, имя БД, пользователя БД, его пароль, адрес хоста и порт, на котором будет запущена БД. Ниже представлены значения некоторых полей по умолчанию.

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Не добавляйте <code>settings.ini</code> в ваш репозиторий, так как он содержит пароли и ключи. Чтобы случайно его не закоммитить добавьте соответствующую запись в <code>.gitignore</code>.</p>
</div>

<div class="admonition note">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Если сгенерированный <code>SECRET_KEY</code> содержит символ <code>%</code>, и при этом на этапе запуска приложения возникает ошибка парсинга - продублируйте <code>%</code> везде в ключе, где этот символ встречается.</p>
</div>

```python
[settings]
SECRET_KEY=MY_SECRET_KEY
DB_NAME=postgres
DB_USER=postgres
DB_PASSWORD=
DB_HOST=db
DB_PORT=5432
```

В файле `manage.py` необходимо заменить имеющийся путь к конфигурации проекта на следующий:
```python
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.local")
```

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Для знакомства с докером можно почитать статью <a href="http://djangostars.com/blog/what-is-docker-and-how-to-use-it-with-python/">What is docker and how to use it with python</a>, а также занимательную статью в <a href="http://grishaev.me/docker">блоге</a> Ивана Гришаева. Дополнительно можете посмотреть выступление Антона Егорова с Moscow Python: <a href="https://www.youtube.com/watch?v=X2jlKUHbepY">Докеризация приложений на Python</a>.</p>
</div>

Создадим docker-окружение для разработки и запуска нашего проекта. Установите докер для вашей системы (инструкции можно получить [тут](https://docs.docker.com/engine/installation/)) и создайте `Dockerfile` в корне вашего проекта:

```bash
FROM python:3.6
ENV PYTHONUNBUFFERED 1
RUN mkdir /config
COPY requirements /config/requirements
RUN pip install -r /config/requirements/dev.txt
RUN mkdir /src;
WORKDIR /src
```

**TODO**: Пояснения к Dockerfile

Теперь в корне проекта создадим файл `docker-compose.yml`:

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Обратите внимание на <code>sleep 5</code>. Это очень наивное решение <a href="https://8thlight.com/blog/dariusz-pasciak/2016/10/17/docker-compose-wait-for-dependencies.html">проблемы зависимостей</a> между контейнерами.</p>
</div>

```
version: '3'
services:
    nginx:
        image: nginx:latest
        container_name: ng01
        ports:
            - "8000:8000"
        volumes:
            - ./deploy/nginx:/etc/nginx/conf.d
        depends_on:
            - web
    web:
        build: .
        container_name: dg01
        command: bash -c "sleep 5 && python manage.py makemigrations && python manage.py migrate && uwsgi --ini /usr/local/etc/elevennote.ini"
        depends_on:
            - db
        volumes:
            - ./src:/src
            - ./deploy/uwsgi:/usr/local/etc/
        expose:
            - "8000"
    db:
        image: postgres:latest
        container_name: ps01
```

**TODO**: Пояснения к docker-compose.yml

```bash
$ mkdir -p deploy/uwsgi
```

`deploy/uwsgi/elevennote.ini`
```ini
[uwsgi]
chdir = /src
module = config.wsgi:application
master = true
processes = 5
socket = 0.0.0.0:8000
vacuum = true
die-on-term = true
env = DJANGO_SETTINGS_MODULE=config.settings.local
```

**TODO**: Пояснения к конфигурации uwsgi

```bash
$ mkdir deploy/nginx
```

`deploy/nginx/elevennote.conf`
```
upstream web {
    ip_hash;
    server web:8000;
}

server {
    location / {
        include uwsgi_params;
        uwsgi_pass web;
    }
    listen 8000;
    server_name localhost;
}
```

**TODO**: Пояснения к nginx


На текущий момент структура вашего проекта должна быть следующей:
```
.
├── Dockerfile
├── deploy
│   ├── nginx
│   │   └── elevennote.conf
│   └── uwsgi
│       └── elevennote.ini
├── docker-compose.yml
├── requirements
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
└── src
    ├── config
    │   ├── __init__.py
    │   ├── settings
    │   │   ├── __init__.py
    │   │   ├── base.py
    │   │   ├── local.py
    │   │   ├── production.py
    │   │   └── settings.ini
    │   ├── urls.py
    │   └── wsgi.py
    └── manage.py
```

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Если на данном этапе возникнет ошибка <code>UnicodeDecodeError</code>, выполните команду <code>rm -rf ~/.docker/config.json</code> для ее устранения.</p>
</div>

```bash
$ docker-compose build
$ docker-compose up
```

Теперь приложение запущено и вы можете обратиться к нему по адресу [http://localhost:8000](http://localhost:8000), где должны увидеть стандартное приветствие Django:

<img src="/assets/images/07-elevennote/elevennote1.png">

На текущий момент осталась одна нерешенная проблема - обработка статических файлов (css/js/и т.д.). Если пройти по адресу [http://localhost:8000/admin](http://localhost:8000/admin), то мы увидим форму без применения стилей:

<img src="/assets/images/07-elevennote/elevennote2.png">

Если же обработка статических файлов настроена верно, то мы должны увидеть следующую форму:

<img src="/assets/images/07-elevennote/elevennote2_1.png">

<div class="admonition note">
  <p class="first admonition-title"><strong>Подсказка</strong></p>
  <p class="last">Если у вас пока не получается справится с этой проблемой, то вы можете найти решение в репозитории для этой работы.</p>
</div>

**Задание**: Решите обозначенную проблему путем внесения соответствующих изменений в `docker-compose.yml`, `deploy/nginx/elevennote.conf` и `src/config/settings/base.py`.

На текущий момент нам больше не нужно виртуальное окружение, так как эту часть функций, а именно изоляции окружения, на себя взял докер.

Создадим суперпользователя, чтобы иметь возможность заходить в панель администратора. Для этого подключимся к контейнеру:

```sh
$ docker exec -it dg01 bash
root@67a3bcc5c881:/src# python manage.py createsuperuser
Username (leave blank to use 'root'):
Email address:
Password:
Password (again):
Superuser created successfully.
root@67a3bcc5c881:/src# exit
```

Создадим новое приложение `notes` (заметки) и добавим его в `INSTALLED_APPS`:

<div class="admonition note">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Убедитесь, что в папке <code>src</code> появилась папка <code>notes</code>, в которой нужно располагать все файлы, касающиеся приложения <code>notes</code>.</p>
</div>

```bash
$ docker-compose run web python manage.py startapp notes
```

`src/config/settings/base.py`
```python
INSTALLED_APPS = [
    # ...
    'notes',
]
```

Создадим первую модель `Note` со следующими полями:
- заголовок (`title`) с ограничением 200 символов;
- текст заметки (`body`);
- и датой создания (`pub_date`).

`notes/models.py`
```python
class Note(models.Model):
    title = models.CharField(max_length=200)
    body = models.TextField()
    pub_date = models.DateTimeField('date published')
```

Зарегистрируем созданную модель в панели администратора:
`notes/admin.py`
```python
from django.contrib import admin
from .models import Note

admin.site.register(Note)
```

И применим внесенные изменения к БД:

<div class="admonition note">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Миграцию необходимо выполнять всякий раз, когда изменяется структура базы данных (добавление/удаление полей, редактирование их свойств и т.д.), но при перезапуске контейнера <code>web</code> это будет происходить автоматически.</p>
</div>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">При необходимости вы можете перезапустить контейнер <code>web</code> командой <code>docker-compose restart web</code>.</p>
</div>

```bash
$ docker-compose run web python manage.py makemigrations notes
$ docker-compose run web python manage.py migrate
$ docker-compose restart web
```

Теперь откройте панель администратора [http://localhost:8000/admin](http://localhost:8000/admin). Вы должны увидеть новый раздел `Notes`, в котором вы можете создавать, редактировать и удалять заметки.

<img src="/assets/images/07-elevennote/elevennote3.png">

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">На момент составления этой работы <code>django-admin-honeypot</code> не совместим с Django версии 2 (и скорее всего уже не будет). Поэтому представленный пример работает только для более ранних версий фреймворка.</p>
</div>

Вы могли заметить, что путь по умолчанию для входа в панель администратора - `/admin`. В случае, если вы хотите предотвратить потенциальные автоматизированные атаки на ваш ресурс путем подбора логина и пароля, или же есть любые иные причины ограничить доступ к панели администратора путем изменения адреса, по которому она будет доступна, вы можете обратить внимание на модуль [admin-honeypot](https://github.com/dmpayton/django-admin-honeypot), который также будет вести историю попыток входа в фейковую панель администратора.

Этот этап не обязателен, вы можете его пропустить или вернуться к нему позже.

```bash
$ docker exec -it dg01 bash
root@67a3bcc5c881:/src# pip install django-admin-honeypot==1.0.0
root@67a3bcc5c881:/src# exit
```

`src/config/settings/base.py`
```python
INSTALLED_APPS = [
    # ...
    'admin_honeypot',
    # ...
]
```

`src/config/urls.py`
```python
urlpatterns = [
    url(r'^admin/', include('admin_honeypot.urls', namespace='admin_honeypot')),
    url(r'^secret/', admin.site.urls),
]
```

Логи попыток входа:

<img src="/assets/images/07-elevennote/elevennote4.png">

Вернемся к приложению с заметками. На текущий момент, если создать новую заметку через панель администратора, то она будет отображаться следующим образом:

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Мы также можем переопределить метод <code>__str__</code> у модели <code>Note</code>.</p>
</div>

<img src="/assets/images/07-elevennote/elevennote5_1.png">

Сделаем отображение заметки в панели администратора более дружелюбным, отображая название заметки и дату публикации. Дополнительно добавим поле, указываюещее на то, была ли заметка опубликована в течениии последних 24-х часов:

`src/notes/admin.py`

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Узнать больше о расширении панели администратора можно в <a href="https://docs.djangoproject.com/en/2.0/ref/contrib/admin/">официальной документации</a>.</p>
</div>

```python
class NoteAdmin(admin.ModelAdmin):
    list_display = ('title', 'pub_date', 'was_published_recently')
    list_filter = ['pub_date']

admin.site.register(Note, NoteAdmin)
```

Мы ссылаемся на новый метод `was_published_recently`, который нужно добавить в модель `Note`:

`src/notes/models.py`
```python
from django.db import models
from django.utils import timezone

class Note(models.Model):
    # ...

    def was_published_recently(self):
        return self.pub_date >= timezone.now() - timezone.timedelta(days=1)
```

<img src="/assets/images/07-elevennote/elevennote5.png">

Давайте напишем наш первый тест, который будет проверять, что отложенная заметка не является недавно опубликованной:

```bash
$ mkdir src/notes/tests
$ mv src/notes/tests.py src/notes/tests/test_models.py
$ touch src/notes/tests/__init__.py
```

`src/notes/tests/test_models.py`
```python
from django.utils import timezone
from django.test import TestCase

from notes.models import Note

class NoteMethodTests(TestCase):

    def test_was_published_recently(self):
        """
        was_published_recently() should return False for notes whose pub_date is in the future.
        """
        time = timezone.now() + timezone.timedelta(days=30)
        future_note = Note(pub_date=time)
        self.assertEqual(future_note.was_published_recently(), False)
```

```bash
$ docker-compose run web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
F
======================================================================
FAIL: test_was_published_recently (notes.tests.test_models.NoteMethodTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/src/notes/tests/test_models.py", line 14, in test_was_published_recently
    self.assertEqual(future_note.was_published_recently(), False)
AssertionError: True != False

----------------------------------------------------------------------
Ran 1 test in 0.020s

FAILED (failures=1)
Destroying test database for alias 'default'...
```

Похоже была допущена ошибка в методе `was_published_recently`, давайте исправим ее:

`src/notes/models.py`
```python
# ...
def was_published_recently(self):
    now = timezone.now()
    return now - timezone.timedelta(days=1) <= self.pub_date <= now
```

И снова запустим тесты:

```bash
$ docker-compose run web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
.
----------------------------------------------------------------------
Ran 1 test in 0.006s

OK
Destroying test database for alias 'default'...
```

`src/config/urls.py`
```python
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('notes/', include('notes.urls', namespace='notes')),
    path('admin/', admin.site.urls),
]
```

```bash
$ touch src/notes/urls.py
```

`src/notes/urls.py`
```python
from django.urls import path

from . import views

app_name = 'notes'

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:note_id>/', views.detail, name='detail'),
]
```

`src/notes/views.py`
```python
from django.shortcuts import get_object_or_404, render

from .models import Note


def index(request):
    latest_note_list = Note.objects.order_by('-pub_date')[:5]
    context = {
        'latest_note_list': latest_note_list,
    }
    return render(request, 'notes/index.html', context)

def detail(request, note_id):
     note = get_object_or_404(Note, pk=note_id)
     return render(request, 'notes/detail.html', {'note': note})
```

```bash
$ mkdir -p src/templates/notes
```

`src/config/settings/base.py`
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [root('templates')],
        # ...
    },
]
```

`src/templates/notes/index.html`
{% raw %}
```html
{% if latest_note_list %}
   <ul>
   {% for note in latest_note_list %}
     <li><a href="{% url 'notes:detail' note.id %}">{{ note.title }}</a></li>
   {% endfor %}
   </ul>
{% else %}
  <p>No notes available.</p>
{% endif %}
```
{% endraw %}

`src/templates/notes/detail.html`
{% raw %}
```html
<h1>{{ note.title }}</h1>
<p>{{ note.body }}</p>
```
{% endraw %}

`src/notes/tests/tests_views.py`

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Обратите внимание на использование f-strings, которые были введены в Python 3.6.</p>
</div>

```python
from django.test import TestCase
from django.urls import reverse, resolve

from notes.models import Note
from notes.views import index, detail


class IndexTests(TestCase):

    def setUp(self):
        self.note = Note.objects.create(
            title="Note title", body="Note description")
        url = reverse('notes:index')
        self.response = self.client.get(url)

    def test_index_view_status_code(self):
        self.assertEquals(self.response.status_code, 200)

    def test_index_url_resolves_index_view(self):
        view = resolve('/notes/')
        self.assertEquals(view.func, index)

    def test_index_view_contains_link_to_details_page(self):
        note_detail_url = reverse('notes:detail', kwargs={
            'note_id': self.note.pk})
        self.assertContains(self.response, f'href="{note_detail_url}"')


class DetailTests(TestCase):

    def setUp(self):
        self.note = Note.objects.create(
            title="Note title", body="Note description")
        url = reverse('notes:detail', kwargs={'note_id': self.note.pk})
        self.response = self.client.get(url)

    def test_detail_view_status_code(self):
        self.assertEquals(self.response.status_code, 200)

    def test_detail_url_resolves_detail_view(self):
        view = resolve(f'/notes/{self.note.pk}/')
        self.assertEquals(view.func, detail)
```

```bash
$ docker-compose run web python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
......
----------------------------------------------------------------------
Ran 6 tests in 0.117s

OK
Destroying test database for alias 'default'...
```

Создадим новое приложением `accounts`, которое будет отвечать за хранение информации о пользователях. Также добавим возможность регистрации и авторизации.

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Не забудьте добавить созданное приложение в <code>INSTALLED_APPS</code> в файле <code>src/config/settings/base.py</code>.</p>
</div>

```bash
$ docker-compose run web python manage.py startapp accounts
```

`src/config/urls.py`
<div class="admonition note">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Обратите внимание, что мы используем <code>RedirectView</code> для перенаправления запроса с <code>http://localhost:8000/</code> на <code>htpp://localhost:8000/notes/</code>.</p>
</div>

```python
#...
from django.views.generic import RedirectView

urlpatterns = [
    # Handle the root url.
    path('', RedirectView.as_view(url='notes/')),

    # Accounts app
    path('accounts/', include('accounts.urls', namespace='accounts')),

    # Notes app
    path('notes/', include('notes.urls', namespace='notes')),

    # Admin
    path('admin/', admin.site.urls),
]
```

```bash
$ touch src/accounts/urls.py
```

`src/accounts/urls.py`
```python
from django.urls import path
from django.contrib.auth import views

app_name = 'accounts'

urlpatterns = [
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
]
```

```bash
$ mkdir src/templates/registration
$ touch src/templates/registration/login.html
```

`src/templates/registration/login.html`
{% raw %}
```html
<form action="{% url 'accounts:login' %}" method="post" accept-charset="utf-8">
  {% csrf_token %}
  {% for field in form %}
    <label>{{ field.label }}</label>
    {% if field.errors %}
      {{ field.errors }}
    {% endif %}
    {{ field }}
  {% endfor %}
  <input type="hidden" name="next" value="{{ next }}" />
  <input class="button small" type="submit" value="Submit"/>
</form>
```
{% endraw %}

<img src="/assets/images/07-elevennote/elevennote_signin_old.png">

Отмечаем соответствующие страницы доступными только после авторизации добавлением декоратора `@login_required`:

`src/notes/views.py`
```python
# ...
from django.contrib.auth.decorators import login_required

@login_required
def index(request):
    # ...


@login_required
def detail(request):
    # ...
```

`src/notes/tests/test_views.py`
```python

```

Далее предлагается загрузить набор стилевых компонентов [bootstrap](https://getbootstrap.com/) и поместить их в папку со статичными файлами. Это, в свою очередь, решит обозначенную в начале работы проблему и преобразит внешний вид формы входа.

```bash
$ mkdir src/static
$ cd src/static
$ wget https://github.com/twbs/bootstrap/releases/download/v4.0.0-beta.3/bootstrap-4.0.0-beta.3-dist.zip
$ unzip bootstrap-4.0.0-beta.3-dist.zip -d bootstrap
$ cd -
```

`src/config/settings/base.py`
```python
# ...
STATIC_URL = '/static/'
STATIC_ROOT = '/static'
STATICFILES_DIRS = [
    root('static'),
]
```

```bash
$ docker exec -it dg01 bash
root@67a3bcc5c881:/src# pip install django-widget-tweaks
root@67a3bcc5c881:/src# exit
$ echo "django-widget-tweaks==1.4.1" >> requirements/base.txt
```

`src/config/settings/base.py`
```python
INSTALLED_APPS = [
    # ...
    'widget_tweaks',
]
```

```bash
# Fix me
wget https://github.com/sixfeetup/ElevenNote/raw/master/templates-ch06.zip
unzip templates-ch6.zip   # If prompted to replace, say (Y)es
cd ..
```

<img src="/assets/images/07-elevennote/elevennote_signin_new.png">

Добавляем возможность регистрации.

`src/accounts/views.py`
```python
from django.contrib.auth import authenticate, login
from django.contrib.auth.forms import UserCreationForm
from django.views.generic import FormView


class RegisterView(FormView):
    template_name = 'registration/register.html'
    form_class = UserCreationForm
    success_url='/'

    def form_valid(self, form):
        #save the new user first
        form.save()

        #get the username and password
        username = self.request.POST['username']
        password = self.request.POST['password1']

        #authenticate user then login
        user = authenticate(username=username, password=password)
        login(self.request, user)
        return super(RegisterView, self).form_valid(form)
```

`src/accounts/urls.py`
```python
from django.urls import path, reverse_lazy
from django.contrib.auth import views as auth_views

from .views import RegisterView

app_name = 'accounts'

urlpatterns = [
    path('login/', auth_views.login, name='login'),
    path('logout/', auth_views.logout, {"next_page" : reverse_lazy('accounts:login')}, name='logout'),
    path('register/', RegisterView.as_view(), name='register'),
]
```

Далее настраивается адрес, на который будет осуществлен переход по факту успешной авторизации/регистрации.

`config/settings/base.py`
```python
# ...
LOGIN_REDIRECT_URL = '/'
```

<img src="/assets/images/07-elevennote/elevennote_signup_new.png">

`src/templates/registration/login.html`
{% raw %}
```html
<a href="{% url 'accounts:register' %}">Create a new user</a>
```
{% endraw %}


`accounts/tests/test_views.py`
```python

```

Добавим в модель заметки информацию об авторе - пользователе, создавшем ее - путем внесения внешнего ключа.

`src/notes/models.py`
```python
# ...
from django.contrib.auth.models import User


class Note(models.Model):
    # ...
    owner = models.ForeignKey(User, related_name='notes', on_delete=models.CASCADE)
```

Как говорилось ранее, вследствие изменения структуры базы данных необходимо выполнить миграцию.

**TODO**: выбор значения по умолчанию

```bash
$ docker exec -it dg01 bash
root@67a3bcc5c881:/src# python manage.py makemigrations
root@67a3bcc5c881:/src# python manage.py migrate
root@67a3bcc5c881:/src# exit
```

В выводимый список заметок добавим сортировку по убыванию даты публикации и ограничим выводимое количество (5 шт.). Позже можно убрать количественное ограничение для возможности постраничного просмотра имеющихся заметок.

`notes/views.py`
```python
latest_note_list = Note.objects.filter(owner=request.user).order_by('-pub_date')[:5]
```

`notes/admin.py`
```python
list_display = ('title', 'owner', 'pub_date', 'was_published_recently')
```


`notes/views.py`
```python
from django.utils.decorators import method_decorator
from django.contrib.auth.decorators import login_required
from django.views.generic import ListView, DetailView

from .models import Note


class NoteList(ListView):
    paginate_by = 5
    template_name = 'notes/index.html'
    context_object_name = 'latest_note_list'

    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(NoteList, self).dispatch(*args, **kwargs)

    def get_queryset(self):
        return Note.objects.filter(owner=self.request.user)


class NoteDetail(DetailView):
    model = Note
    template_name = 'notes/detail.html'
    context_object_name = 'note'

    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(NoteDetail, self).dispatch(*args, **kwargs)
```

`notes/urls.py`
```python
from django.urls import path

from .views import NoteList, NoteDetail

app_name = 'notes'

urlpatterns = [
    path('', NoteList.as_view(), name='index'),
    path('<int:pk>/', NoteDetail.as_view(), name='detail'),
]
```

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">В <a href="https://github.com/sixfeetup/ElevenNote/wiki/09-Intro-to-Mixins">руководстве</a> от Six Feet Up объясняется как создать собственный миксин, который бы решал аналогичную задачу.</p>
</div>

`notes/views.py`
```python
from django.contrib.auth.mixins import LoginRequiredMixin


class NoteList(LoginRequiredMixin, ListView):
    # ...

class NoteDetail(LoginRequiredMixin, DetailView):
    # ...
```

`notes/forms.py`

```python
from django import forms

from .models import Note

class NoteForm(forms.ModelForm):

    class Meta:
        model = Note
        fields = ['title', 'body']
```

`notes/views.py`
```python
from django.views.generic import ListView, DetailView, CreateView
from django.utils import timezone
from django.urls import reverse_lazy

from .forms import NoteForm
...

class NoteCreate(LoginRequiredMixin, CreateView):
    form_class = NoteForm
    template_name = 'notes/form.html'
    success_url = reverse_lazy('notes:index')

    def form_valid(self, form):
        form.instance.owner = self.request.user
        form.instance.pub_date = timezone.now()
        return super(NoteCreate, self).form_valid(form)
```

`src/notes/urls.py`
```python
path('new/', NoteCreate.as_view(), name='create'),
```

Добавляем шаблон формы, используемый для создания и редактирования заметок.
Убедитесь в наличии шаблона `base.html`, от которого ряд других шаблонов будет наследоваться.
Используемая логика: `base.html` реализует базовый интерфейс в виде шапки ресурса, в которой отображается имя авторизованного пользователя и кнопка выхода, в то время как наследники реализуют интерфейс отдельного модуля в блоке `content`

`src/templates/notes/form.html`
{% raw %}
```html
{% extends "base.html" %}

{% block content %}

<form action="{% url 'notes:create' %}" method="post" accept-charset="utf-8">
    {% csrf_token %}
    {% include 'includes/form.html' %}
    <input type="hidden" name="next" value="{{ next }}" />
    <input class="btn btn-success" type="submit" value="Submit"/>
</form>

{% endblock %}
```
{% endraw %}

<img src="/assets/images/07-elevennote/elevennote_create_new.png">

Добавим возможность создания новой заметки в интерфейс общего списка заметок.

`src/templates/notes/index.html`
{% raw %}
```html
<a href="{% url 'notes:create' %}">Create a new note</a>
```
{% endraw %}

Добавим возможность постраничного просмотра имеющихся заметок.

`src/template/notes/index.html`
{% raw %}
```html
{% if is_paginated %}
<div class="pagination">
   <span class="step-links">
       {% if page_obj.has_previous %}
           <a href="?page={{ page_obj.previous_page_number }}">previous</a>
       {% endif %}

       <span class="current">
           Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.
       </span>

       {% if page_obj.has_next %}
          <a href="?page={{ page_obj.next_page_number }}">next</a>
       {% endif %}
  </span>
</div>
{% endif %}
```
{% endraw %}

Пользователь должен иметь доступ только к тем заметкам, автором которых является.

`src/notes/views.py`
```python
return Note.objects.filter(owner=self.request.user)
```

```python
return Note.objects.filter(owner=self.request.user).order_by('-pub_date')
```

Для возможности обширного редактирования заметок (функции для выделения текста, использование различных шрифтов, вставка ссылок, изображений и т. д.) предлагается к использованию модуль [django-wysiwyg](https://github.com/pydanny-archive/django-wysiwyg).

```bash
$ docker exec -it dg01 bash
root@67a3bcc5c881:/src# python -m pip install django-wysiwyg
root@67a3bcc5c881:/src# exit
$ echo "django-wysiwyg==0.8.0" >> requirements/base.txt
```

`src/config/settings/base.py`
```python
INSTALLED_APPS = [
    # ...
    'django_wysiwyg',
    # ...
]

#...
DJANGO_WYSIWYG_FLAVOR = 'ckeditor'
```

Далее нужно загрузить предпочитаемый редактор текста.

```bash
$ cd src/static
$ wget https://download.cksource.com/CKEditor/CKEditor/CKEditor%204.7.2/ckeditor_4.7.2_full.zip
$ unzip ckeditor_4.7.2_full.zip
$ cd -
```

Предотвращение неправомерного доступа.

`src/notes/views.py`
```python
from django.core.exceptions import PermissionDenied

...

# In NoteDetail class, override the get() method to raise an
# error if the user tries to view another user's note.

def get(self, request, *args, **kwargs):
    self.object = self.get_object()

    if self.object.owner != self.request.user:
        raise PermissionDenied

    context = self.get_context_data(object=self.object)
    return self.render_to_response(context)
```

`src/notes/views.py`
```python
from django.views.generic import ListView, DetailView, CreateView, UpdateView

...

class NoteUpdate(LoginRequiredMixin, UpdateView):
    model = Note
    form_class = NoteForm
    template_name = 'notes/form.html'
    success_url = reverse_lazy('notes:index')

    def form_valid(self, form):
       form.instance.pub_date = timezone.now()
       return super(NoteUpdate, self).form_valid(form)
```

`src/notes/urls.py`
```python
# ...
from .views import NoteList, NoteDetail, NoteCreate, NoteUpdate
# ...

path('<int:pk>/edit/', NoteUpdate.as_view(), name='update'),
```

`src/templates/notes/form.html`
{% raw %}
```html
{% if object %}
<form action="{% url 'notes:update' object.pk %}" method="post" accept-charset="utf-8">
{% else %}
<form action="{% url 'notes:create' %}" method="post" accept-charset="utf-8">
{% endif %}
```
{% endraw %}

`src/templates/notes/detail.html`
{% raw %}
```html
<a href="{% url 'notes:update' note.id %}">Edit</a>
```
{% endraw %}

`src/templates/notes/detail.html`
{% raw %}
```html
<p>
   <a href="{% url 'notes:update' note.id %}">{{ note.title }}</a><br />
   {{ note.body | safe }}
</p>
<hr />
```
{% endraw %}

`src/notes/mixins.py`
```python
from .models import Note


class NoteMixin(object):
   def get_context_data(self, **kwargs):
       context = super(NoteMixin, self).get_context_data(**kwargs)

       context.update({
          'notes': Note.objects.filter(owner=self.request.user).order_by('-pub_date'),
       })

       return context
```

`src/notes/views.py`
```python
class NoteCreate(LoginRequiredMixin, NoteMixin, CreateView):
```

```python
class NoteUpdate(LoginRequiredMixin, NoteMixin, UpdateView):

    ...
    def get(self, request, *args, **kwargs):
        self.object = self.get_object()

        if self.object.owner != self.request.user:
            raise PermissionDenied

        return super(NoteUpdate, self).get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()

        if self.object.owner != self.request.user:
            raise PermissionDenied

        return super(NoteUpdate, self).post(request, *args, **kwargs)
```

```bash
$ wget https://github.com/sixfeetup/ElevenNote/raw/master/templates-ch16.zip
$ unzip templates-ch16.zip
```

```bash
cd static
wget https://github.com/sixfeetup/ElevenNote/raw/master/static-elevennote-ch16.zip
unzip static-elevennote-ch16.zip
cd ..
```

<img src="/assets/images/07-elevennote/elevennote_new_styles.png">

`src/notes/mixins.py`
```python
def check_user_or_403(self, user):
    """ Issue a 403 if the current user is no the same as the `user` param. """
    if self.request.user != user:
        raise PermissionDenied
```

`src/notes/views.py`
```python
# ...
from django.views.generic import (
    ListView, DetailView, CreateView, UpdateView, DeleteView
)
# ...

class NoteDelete(LoginRequiredMixin, NoteMixin, DeleteView):
    model = Note
    success_url = reverse_lazy('notes:index')

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        self.check_user_or_403(self.object.owner)
        return super(NoteDelete, self).post(request, *args, **kwargs)
```

`src/notes/urls.py`
```python
# ...
from .views import NoteList, NoteDetail, NoteCreate, NoteUpdate, NoteDelete
# ...
path('<int:pk>/delete/', NoteDelete.as_view(), name='delete'),
```

Предоставление возможности удаления заметки.

`src/templates/base.html`
{% raw %}
```html
<link rel="stylesheet" media="all" href='{% static "font-awesome/css/font-awesome.css" %}'>
```
{% endraw %}

`src/templates/notes/form.html`
{% raw %}
```html
{% if object %}
<form action="{% url 'notes:delete' object.pk %}" method="post" id="delete-note-form">
    {% csrf_token %}
    <a class="btn btn-outline-dark" id="delete-note">
        <i class="fa fa-trash" aria-hidden="true"></i>
    </a>
</form>
{% endif %}
```
{% endraw %}


`src/notes/views.py`
```python
def get_success_url(self):
    return reverse('notes:update', kwargs={
        'pk': self.object.pk
    })
```

**Задание:** Добавьте возможность указывать теги у каждой заметки (можете использовать [Bootstrap Tags Input](https://bootstrap-tagsinput.github.io/bootstrap-tagsinput/examples/) для отображения и управления тегами на стороне клиента, см. скриншот ниже). Последующее редактирование заметок должно быть асинхронным (с использованием технологии AJAX). При нажатии на тег должен выводиться список только тех заметок, у которых указан этот тег.

<img src="/assets/images/07-elevennote/elevennote8.png">

### Continuous Integration с CircleCI


### Добавляем API с помощью DRF

```bash
$ pip install djangorestframework
$ python manage.py api
```

`config/settings/base.py`
```python
INSTALLED_APPS = [
    # ...
    'rest_framework',
    # ...
    'api',
]
```

`api/base/serializers.py`
```python
from rest_framework import serializers

from notes.models import Note

class NoteSerializer(serializers.ModelSerializer):

    class Meta:
        model = Note
        fields = ('id', 'title', 'body', 'pub_date')
```
