<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Лекция 01. Основные типы данных</title>
  <meta name="description" content="Эта лекция посвящена рассмотрению основных типов данных, таких как: числа, строки, списки, кортежи, множества и словари. Рассматривается внтуреннее представление некоторых типов, а также «родителя» всех объектов - структуры PyObject. На вопрос «Зачем?», можно ответить, что во-первых, Python скрывает «стоимость» выполнения большинства операций, например, «Сколько памяти требуется для создания новой переменной?». Так, массив из тысячи небольших целых чисел на 4 килобайта «тяжелее» чем аналогичный массив вещественных чисел; массив нулей требует меньше памяти, чем аналогичный по длине массив любых других целых чисел и т.д. Во-вторых, когда Python кажется нам недостаточно производительным, то мы используем сторонние библиотеки, такие как numpy, или пишем Си-расширения, а чтобы иметь возможность писать последние - необходимо понимать Python/C API.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dementiy.github.io/2018/08/11/01-basic-data-types/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Ein Blog für freie Geister" href="https://dementiy.github.io/feed.xml">

  <link rel="icon" type="image/x-icon" href="/favicon.ico">


  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Лекция 01. Основные типы данных">
  <meta name="twitter:description" content="Эта лекция посвящена рассмотрению основных типов данных, таких как: числа, строки, списки, кортежи, множества и словари. Рассматривается внтуреннее представление некоторых типов, а также «родителя»...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-111461883-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Ein Blog für freie Geister</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/practice/">Py&Go Practice</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/Dementiy/">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Лекция 01. Основные типы данных</h1>
    
    <p class="post-meta"><time datetime="2018-08-11T00:00:00+03:00" itemprop="datePublished">Aug 11, 2018</time> • 
  
  
    
      <a href="/categories/python/">python</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8/">лекции</a>
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Эта лекция посвящена рассмотрению основных типов данных, таких как: числа, строки, списки, кортежи, множества и словари. Рассматривается внтуреннее представление некоторых типов, а также «родителя» всех объектов - структуры <code class="highlighter-rouge">PyObject</code>. На вопрос «Зачем?», можно ответить, что во-первых, Python скрывает «стоимость» выполнения большинства операций, например, «Сколько памяти требуется для создания новой переменной?». Так, массив из тысячи небольших целых чисел на 4 килобайта «тяжелее» чем аналогичный массив вещественных чисел; массив нулей требует меньше памяти, чем аналогичный по длине массив любых других целых чисел и т.д. Во-вторых, когда Python кажется нам недостаточно производительным, то мы используем сторонние библиотеки, такие как numpy, или пишем Си-расширения, а чтобы иметь возможность писать последние - необходимо понимать <a href="https://docs.python.org/3/c-api/index.html">Python/C API</a>.</p>

<script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h3 id="everything-is-an-object">«Everything is an Object»</h3>

<p>В Python все является объектом: числа, последовательности, функции, классы, модули и т.д. Каждый объект обладает уникальным идентификатором, который никогда не изменяется после создания объекта (в CPython идентификатором объекта является его адрес в памяти, который можно получить с помощью встроенной функции <code class="highlighter-rouge">id()</code>), типом, который определяет «чем является объект» (числом, строкой, списком и т.д.) и какие действия над ним можно выполнять, а также значением.</p>

<p>Каждый объект «наследуется» от Си-структуры <a href="https://github.com/python/cpython/blob/master/Include/object.h#L106"><code class="highlighter-rouge">PyObject</code></a> или <code class="highlighter-rouge">PyVarObject</code> для объектов переменной (variable) длинны (строки, списки и т.д.):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">_PyObject_HEAD_EXTRA</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Где:</p>

<ul>
  <li><code class="highlighter-rouge">_PyObject_HEAD_EXTRA</code> - макрос, который определяет два поля <code class="highlighter-rouge">_ob_next</code> и <code class="highlighter-rouge">_ob_prev</code> - указатели на следующий и предыдущий объекты, соответственно. Будут ли эти поля включены в структуру <code class="highlighter-rouge">PyObject</code> или нет - зависит от флага <code class="highlighter-rouge">Py_TRACE_REFS</code>, который по умолчанию не установлен;</li>
  <li><code class="highlighter-rouge">ob_refcnt</code> - счетчик ссылок на объект, который увеличивается или уменьшается, при копировании или удалении указателя на объект; когда счетчик ссылок достигает нуля, то объект удаляется. Про подсчет ссылок и «сборку мусора» мы будем говорить в одной из следующих лекций;</li>
  <li><code class="highlighter-rouge">ob_type</code> - указатель на структуру <a href="https://docs.python.org/3/c-api/typeobj.html"><code class="highlighter-rouge">_typeobject</code></a>, которая задает тип объекта (более подробно об этой структуре мы будем говорить в лекции «Си-расширения»).</li>
</ul>

<p>Структура <code class="highlighter-rouge">PyVarObject</code> включает одно дополнительное поле <code class="highlighter-rouge">ob_size</code> - количество элементов в объекте (например, для списка из пяти элементов <code class="highlighter-rouge">ob_size</code> будет равен 5):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject</span> <span class="n">ob_base</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_size</span><span class="p">;</span> <span class="cm">/* Number of items in variable part */</span>
<span class="p">}</span> <span class="n">PyVarObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Итак, если вы решили ввести свой тип, то он должен «наследоваться» от <code class="highlighter-rouge">PyObject</code> или <code class="highlighter-rouge">PyVarObject</code> с помощью макросов <code class="highlighter-rouge">PyObject_HEAD</code> и <code class="highlighter-rouge">PyObject_VAR_HEAD</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PyObject_HEAD          PyObject ob_base;
</span><span class="p">...</span>
<span class="cp">#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span></code></pre></div></div>

<p>Например:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_myobject</span> <span class="p">{</span>
       <span class="n">PyObject_HEAD</span>
       <span class="p">...</span>
<span class="p">}</span> <span class="n">PyMyObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Таким образом, <code class="highlighter-rouge">PyMyObject</code> будет содержать все поля, которые есть в <code class="highlighter-rouge">PyObject</code>.</p>

<p>Следует помнить, что макрос <code class="highlighter-rouge">PyObject_HEAD</code> должнен идти первым в структуре. Это связано с «наследованием», о котором говорилось ранее. Как утверждается в <a href="https://github.com/python/cpython/blob/master/Include/object.h#L40"><code class="highlighter-rouge">object.h</code></a>:</p>

<blockquote>
  <p>Objects are always accessed through pointers of the type <code class="highlighter-rouge">PyObject *</code></p>
</blockquote>

<p>и означает, что должна быть возможность приведения (casting) указателя на <code class="highlighter-rouge">PyMyObject</code> к указателю на <code class="highlighter-rouge">PyObject</code>, то есть:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span><span class="n">my_py_type_variable</span><span class="p">;</span>
</code></pre></div></div>

<p>Мы вкратце рассмотрели наиболее общие структуры для представления объектов в CPython, но пока не говорили о том как создаются новые объекты. В одной из последующих лекций мы вернемся к этому вопросу. Далее мы рассмотрим основные типы данных и внутреннее представление некоторых из них.</p>

<h3 id="целочисленный-тип-данных-и-числа-с-плавающей-точкой">Целочисленный тип данных и числа с плавающей точкой</h3>

<p>Без использования стандартной библиотеки языка нам доступны целые числа (int), вещественные числа (float) и комплексные числа (complex).</p>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Процесс создания новой переменной называется name binding, то есть связывание имени с некоторым объектом, в данном случае именем выступает <code>year</code>, а объектом целое число <code>2018</code>.</p>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">2018</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span>
<span class="mi">2018</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">year</span><span class="p">)</span>
<span class="nb">int</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="mi">2018</span><span class="p">)</span>
<span class="nb">int</span>
</code></pre></div></div>

<p>У каждого типа обычно есть «конструктор»:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">zero</span> <span class="o">=</span> <span class="nb">int</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zero</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zero</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">zero</span>
<span class="mf">0.0</span>
</code></pre></div></div>

<p>Основные арифметические операции:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2019</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">-</span> <span class="mi">1</span>
<span class="mi">2017</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">*</span> <span class="mi">12</span>
<span class="mi">24216</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">*</span> <span class="mf">365.25</span>
<span class="mf">737074.5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">/</span> <span class="mi">100</span>
<span class="mf">20.18</span>
</code></pre></div></div>

<p>Взятие целой части и остатка от деления:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">//</span> <span class="mi">100</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">year</span> <span class="o">%</span> <span class="mi">100</span>
<span class="mi">18</span>
</code></pre></div></div>

<p>Для записи очень больших или очень маленьких чисел удобно использовать экспоненциальную форму записи чисел. Сравните:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mf">2.018</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="mi">3</span>
<span class="mf">2017.9999999999998</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">2.018E3</span>
<span class="mf">2018.0</span>
</code></pre></div></div>

<p>И не стоит забывать про <a href="https://floating-point-gui.de/errors/rounding/">ошибки округления</a> при работе с вещественными числами:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span>
<span class="mf">0.9999999999999999</span>
</code></pre></div></div>

<h3 id="длинная-арифметика-в-python">Длинная арифметика в Python</h3>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Значительная часть материала про представление целых чисел взята из статьи Артема Голубина: <a href="https://rushter.com/blog/python-integer-implementation/">Python Integer Implementation</a>.</p>
</div>

<p>Может ли произойти переполнение при работе с целыми числами в Python? Нет, если мы <strong>не</strong> говорим о таких пакетах как Numpy и Pandas, так как при работе с целыми числами в Python используется <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BB%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0">длинная арифметика</a>.</p>

<p>Следующая структура отвечает за представление целых чисел:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_longobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="n">digit</span> <span class="n">ob_digit</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PyLongObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Если «раскрыть» макрос <code class="highlighter-rouge">PyObject_VAR_HEAD</code>, то стурктура будет выглядеть следующим образом:</p>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Вы должны были заметить, что <code>PyLongObject</code> «наследуется» от <code>PyVarObject</code>, то есть является объектом переменной длины, и, таким образом, включает поле <code>ob_size</code>, которое в данном случае содержит размер массива <code>ob_digit</code>.</p>
</div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_longobject</span> <span class="p">{</span>
    <span class="kt">ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">ob_size</span><span class="p">;</span> 
    <span class="kt">uint32_t</span> <span class="n">ob_digit</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PyLongObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Все поля вам уже должны быть знакомы, <code class="highlighter-rouge">PyLongObject</code> добавляет лишь одно новое поле <code class="highlighter-rouge">ob_digit</code> - массив беззнаковых целых чисел по основанию <script type="math/tex">2^{30}</script>. Давайте разберемся с назначением этого поля.</p>

<h3 id="представление-произвольно-больших-целых-чисел">Представление произвольно больших целых чисел</h3>

<p>Как хранить произвольно большое целое число? Одним из решений является представление целого числа в виде массива отдельных цифр. Для наиболее эффективного использования памяти мы можем конвертировать наше число из десятичной системы счисления в систему счисления по основанию <script type="math/tex">2^{30}</script>, в таком случае каждый элемент представлен «цифрой» в диапазоне от <script type="math/tex">0</script> до <script type="math/tex">2^{30} - 1</script>. В зависимости от платформы Python использует или 32-битные беззнаковые массивы с 30-битными цифрами или 16-битные беззнаковые массивы с 15-битными цифрами. Такой подход представления больших целых чисел связан с <a href="https://github.com/python/cpython/blob/865e4b4f630e2ae91e61239258abb58b488f1d65/Include/longintrepr.h#L9">дополнительными ограничениями</a>, которые и не позволяют использовать все биты. Поле <code class="highlighter-rouge">ob_digit</code> структуры показанной выше, содержит такие массивы цифр.</p>

<p>Для избежания лишних вычислений в CPython есть эффективный способ представления целых чисел в диапазоне от <script type="math/tex">-2^{30}</script> до <script type="math/tex">2^{30}</script>. Такие целые числа хранятся как массивы с одним элементом, то есть, состоящие из одной цифры.</p>

<p>Также следует отметить, что в отличие от классического представления знака числа (т.е. использования знакового бита), знак целого числа хранится в поле <code class="highlighter-rouge">ob_size</code>, которое также содержит размер массива <code class="highlighter-rouge">ob_digit</code>. Например, если мы хотим изменить знак целого с размером <code class="highlighter-rouge">ob_size=2</code> (две цифры), то <code class="highlighter-rouge">ob_size</code> станет равным <code class="highlighter-rouge">-2</code>.</p>

<p>Комментарий из исходных текстов по представлению целых чисел:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Long integer representation.
   The absolute value of a number is equal to
   SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
   Negative numbers are represented with ob_size &lt; 0;
   zero is represented by ob_size == 0.
   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
   digit) is never zero.  Also, in all cases, for all valid i,
   0 &lt;= ob_digit[i] &lt;= MASK.
   The allocation function takes care of allocating extra memory
   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.

   CAUTION:  Generic code manipulating subtypes of PyVarObject has to aware that integers abuse  ob_size's sign bit.
*/</span>
</code></pre></div></div>

<p>Давайте рассмотрим конкретный пример преобразования длинного целого в массив и обратно. Пусть у нас имеется следующее число: <script type="math/tex">123456789101112131415</script>. Переведем его в систему счисления по основанию <script type="math/tex">2^{30}</script>, путем последовательного деления и записи остатка от деления:</p>

<p><strong><span style="color: red">TODO: Вставить картинку с процессом деления и структурой PyLongObject</span></strong></p>

<p>Конвертировать число обратно также достаточно просто:</p>

<script type="math/tex; mode=display">(437976919 ∗ 2^{30 ∗ 0}) + (87719511 ∗ 2^{30 ∗ 1}) + (107 ∗ 2^{30 ∗ 2}) = 123456789101112131415</script>

<h3 id="преобразования-длинного-целого-в-массив">Преобразования длинного целого в массив</h3>

<p>Ниже приведен упрощенный вариант алгоритма представления произвольно больших чисел:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SHIFT</span> <span class="o">=</span> <span class="mi">30</span>  <span class="c"># Число бит под каждую «цифру»</span>
<span class="n">MASK</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">SHIFT</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">split_number</span><span class="p">(</span><span class="n">bignum</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bignum</span><span class="p">)</span>

    <span class="n">num_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">t</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># Взятие остатка от деления</span>
        <span class="n">small_int</span> <span class="o">=</span> <span class="n">t</span> <span class="o">%</span> <span class="n">MASK</span>  <span class="c"># Побитовый аналог: (t &amp; (MASK-1))</span>
        <span class="n">num_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">small_int</span><span class="p">)</span>

        <span class="c"># Взятие целой части от деления</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">//</span> <span class="n">MASK</span>  <span class="c"># Побитовый аналог: t &gt;&gt;= SHIFT</span>

    <span class="k">return</span> <span class="n">num_list</span>

<span class="k">def</span> <span class="nf">restore_number</span><span class="p">(</span><span class="n">num_list</span><span class="p">):</span>
    <span class="n">bignum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">num_list</span><span class="p">):</span>
        <span class="n">bignum</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">SHIFT</span> <span class="o">*</span> <span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">bignum</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bignum</span> <span class="o">=</span> <span class="mi">123456789101112131415</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">num_list</span> <span class="o">=</span> <span class="n">split_number</span><span class="p">(</span><span class="n">bignum</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">num_list</span>
<span class="p">[</span><span class="mi">437976919</span><span class="p">,</span> <span class="mi">87719511</span><span class="p">,</span> <span class="mi">107</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bignum</span> <span class="o">==</span> <span class="n">restore_number</span><span class="p">(</span><span class="n">num_list</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>Если мы хотим убедиться, что нигде не ошиблись, то можем посмотреть на внутреннее представление целого числа с помощью модуля <a href="https://docs.python.org/3/library/ctypes.html">ctypes</a>, который позволяет взаимодействовать с Си-кодом из Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="k">class</span> <span class="nc">PyLongObject</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_refcnt"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_type"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_size"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_digit"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)]</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bignum</span> <span class="o">=</span> <span class="mi">123456789101112131415</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">PyLongObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">bignum</span><span class="p">))</span><span class="o">.</span><span class="n">ob_digit</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"ob_digit[{i}] = {d}"</span><span class="p">)</span>
<span class="n">ob_digit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">437976919</span>
<span class="n">ob_digit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">87719511</span>
<span class="n">ob_digit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">107</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="s">"ob_size:"</span><span class="p">,</span> <span class="n">PyLongObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">bignum</span><span class="p">))</span><span class="o">.</span><span class="n">ob_size</span><span class="p">)</span>
<span class="n">ob_size</span><span class="p">:</span> <span class="mi">3</span>
</code></pre></div></div>

<h3 id="оптимизации">Оптимизации</h3>

<p>Небольшие целые числа в диапазоне от <code class="highlighter-rouge">-5</code> до <code class="highlighter-rouge">256</code> преаллоцируются в процессе инициализации интерпретатора. Так как целые числа являются неизменяемыми, то мы можем воспринимать их как <a href="https://en.wikipedia.org/wiki/Singleton_pattern">синглтоны</a>. Каждый раз, когда нам необходимо создать небольшое целое число (например, как результат некоторой арифметической операции), то вместо создания нового объекта, Python просто возвращает указатель на уже преаллоцированный объект. Это позволяет сократить количество потребляемой памяти и время затрачиваемое на вычисления при работе с небольшими целыми числами.</p>

<p>Давайте рассмотрим простой пример:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">94220163919104</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">94220163919136</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="mi">94220163919104</span>
</code></pre></div></div>

<p>Следует иметь ввиду, что структура <code class="highlighter-rouge">PyLongObject</code> занимает не менее 28 байт для каждого целого числа, то есть в три раза больше чем требуется под 64-битное целое в языке C.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">28</span>
</code></pre></div></div>

<p>Из чего складывается такой размер? Указатель на структуру <code class="highlighter-rouge">_typeobject</code> занимает восемь байт, также по восемь байт занимают поля <code class="highlighter-rouge">ob_refcnt</code> и <code class="highlighter-rouge">ob_size</code>, что уже в сумме дает нам 24 байта. Каждый элемент массива <code class="highlighter-rouge">ob_digit</code> это еще четыре байта. Итого для небольших целых чисел требуется 28 байт. Но есть одно исключение - <a href="https://stackoverflow.com/a/10365639/1724257">ноль</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">24</span>
</code></pre></div></div>

<h3 id="выполнение-арифметических-операций">Выполнение арифметических операций</h3>

<p>Базовые арифметические операции выполняются аналогично тому, как мы это делали когда-то в школе, с одним исключением: каждый элемент массива считается «цифрой».</p>

<p>Давайте рассмотрим вариант алгоритма сложения с <a href="https://en.wikipedia.org/wiki/Carry_(arithmetic)">переносом</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_bignum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="c"># Убедимся, что в «a» наибольшее из двух значений</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>

    <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">carry</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">carry</span> <span class="o">%</span> <span class="n">MASK</span><span class="p">)</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">//</span> <span class="n">MASK</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">carry</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">carry</span> <span class="o">%</span> <span class="n">MASK</span><span class="p">)</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">carry</span> <span class="o">//</span> <span class="n">MASK</span>

    <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">carry</span><span class="p">)</span>

    <span class="c"># Удалим завершающие нули</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">z</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">8223372036854775807</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100037203685477</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">restore_number</span><span class="p">(</span><span class="n">add_bignum</span><span class="p">(</span><span class="n">split_number</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">split_number</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span> <span class="o">==</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="bp">True</span>
</code></pre></div></div>

<h3 id="замечание-про-numpy-и-pandas">Замечание про Numpy и Pandas</h3>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">См. <a href="http://mortada.net/can-integer-operations-overflow-in-python.html">«Can integer operations overflow in Python»</a>.</p>
</div>

<p>В тех случаях, когда мы пользуемся библиотеками numpy/scipy/pandas и т.д., может произойти переполнение при работе с целыми числами, так как структуры, лежащие в основе этих библиотек, для более эффективного использования памяти, полагаются на соответствующие С-типы ограниченной точности:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ar</span>
<span class="n">array</span><span class="p">([</span><span class="mi">9223372036854775807</span><span class="p">,</span> <span class="mi">9223372036854775807</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">dtype</span><span class="p">(</span><span class="s">'int64'</span><span class="p">)</span>
</code></pre></div></div>

<p>Элементами <code class="highlighter-rouge">ndarray</code> являются 64-битные знаковые целые, таким обрзаом, <script type="math/tex">2^{63}-1</script> наибольшее положительное значение, которое мы можем хранить в <code class="highlighter-rouge">ndarray</code>. Добавление 1 приведет к  переполнению (overflow):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">ar</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">,</span> <span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
<span class="o">-</span><span class="mi">2</span>
</code></pre></div></div>

<p>При вычислении среднего элементы массива сначала приводятся к типу <code class="highlighter-rouge">float</code> и переполнения не возникает:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
<span class="mf">9.2233720368547758e+18</span>
</code></pre></div></div>

<h3 id="числа-с-плавающей-точкой-и-стандарт-ieee-754">Числа с плавающей точкой и стандарт IEEE-754</h3>

<p>Вещественные числа в CPython представлены следующей структурой:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">double</span> <span class="n">ob_fval</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyFloatObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Легко заметить, что поле <code class="highlighter-rouge">ob_fval</code> это обычное вещественное число двойной точности. Все арифметические операции над вещественными числами в Python являются простыми обертками над соответствующими арифметическими операциями в Си, например, операция <a href="https://github.com/python/cpython/blob/master/Objects/floatobject.c#L534">сложения</a> определена следующим образом:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">float_add</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>
    <span class="n">CONVERT_TO_DOUBLE</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">CONVERT_TO_DOUBLE</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">PyFPE_START_PROTECT</span><span class="p">(</span><span class="s">"add"</span><span class="p">,</span> <span class="k">return</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">PyFPE_END_PROTECT</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyFloat_FromDouble</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Следует помнить, что все вычисления в вещественных числах делаются компьютером с некоторой ограниченной точностью (см. стандарт <a href="http://www.softelectro.ru/ieee754.html">IEEE-754</a>), поэтому зачастую вместо «честных» ответов получаются приближенные (к этому надо быть готовым), например:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.1</span>
<span class="mf">0.9999999999999999</span>
</code></pre></div></div>

<p>Если вы не понимаете почему мы не получили единицу, то попробуйте перевести число <script type="math/tex">0.1</script> в двоичную систему счисления:</p>

<script type="math/tex; mode=display">0.1 = \frac{1}{10} = 0*2^{-1} + 0*2^{-2} + 0*2^{-3} + 1*2^{-4} + 1*2^{-5} + ... = 00011(0011)</script>

<p>В некоторых случаях на помощь может придти модуль <code class="highlighter-rouge">fmath</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">fsum</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sum</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="mf">0.9999999999999999</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fsum</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>
<span class="mf">1.0</span>
</code></pre></div></div>

<h3 id="булевый-тип">Булевый тип</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">to_be</span> <span class="o">=</span> <span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">to_be</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">to_be</span>
<span class="bp">True</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">is_leap</span> <span class="o">=</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">year</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">year</span> <span class="o">%</span> <span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">is_leap</span>
<span class="bp">False</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">abrakadabra_or_lazy_evaluation</span>
<span class="bp">True</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<h3 id="строки">Строки</h3>

<p>Строки в Python версии 3 представляют собой последовательность символов Юникод (code point’ов). Если вы никогда не слышали про Юникод и кодировки или плохо представляете, что это такое, то советую прочитать исчерпывающую <a href="http://kunststube.net/encoding/">статью</a> David C. Zentgraf из серии «Что каждый программист должен знать о…».</p>

<p>Новую строку можно создать с помощью одинарных или двойных кавычек (можно использовать и тройные кавычки, но чаще они используются для документирования функций, классов, модулей):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s">'Dmitrii'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">last_name</span> <span class="o">=</span> <span class="s">'Sorokin'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">email</span> <span class="o">=</span> <span class="s">'Dementiy@yandex.ru'</span>
</code></pre></div></div>

<p>Для строк определена операция сложения (конкантенации):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">full_name</span> <span class="o">=</span> <span class="n">first_name</span> <span class="o">+</span> <span class="s">' '</span> <span class="o">+</span> <span class="n">last_name</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">full_name</span>
<span class="s">'Dmitrii Sorokin'</span>
</code></pre></div></div>

<p>Следует иметь ввиду, что в приведенном примере, будет создан промежуточный объект, состоящий из имени и пробела. Если возникает необходимость объединить большое число строк, то вместо последовательного сложения строк следует использовтаь метод <code class="highlighter-rouge">join()</code>, который работает следующим образом - осуществляется проход по всем строкам суммируя их длины, выделяется память под новый размер строки, осуществляется еще один проход по всем строкам копируя их содержимое в новый объект, таким образом, не создается промежуточных объектов:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">full_name</span> <span class="o">=</span> <span class="s">' '</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">full_name</span>
<span class="s">'Dmitrii Sorokin'</span>
</code></pre></div></div>

<p>Здесь мы первый раз сталкиваемся с вызовом метода у объекта. Давайте вспомним, что в Python все является объектом. Каждый объект предоставляет интерфейс (методы) взаимодействия с ним, а также хранит внутреннее состояние посредством переменных. Обращение к методам и переменным объекта (атрибутам) происходит через точку, как в примере выше с методом <code class="highlighter-rouge">join()</code>.</p>

<p>Строку можно разбить на список подстрок по заданному разделителю, который в свою очередь также является строкой:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">email</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'@'</span><span class="p">)</span>
<span class="p">[</span><span class="s">'Dementiy'</span><span class="p">,</span> <span class="s">'yandex.ru'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">username</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'@'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">username</span>
<span class="s">'Dementiy'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">domain</span>
<span class="s">'yandex.ru'</span>
</code></pre></div></div>

<p>Заканчивается ли строка данной подстрокой:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">email</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'yandex.ru'</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>У строк (как и у большинства контейнеров) можно получить длину (число элементов в контейнере):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_name</span><span class="p">)</span> <span class="c"># --&gt; full_name.__len__()</span>
<span class="mi">15</span>
</code></pre></div></div>

<p>Можно обращаться к отдельным элементам строки, которые представляют собой строку из одного символа:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="s">'D'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">first_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="s">'i'</span>
</code></pre></div></div>

<p>Строки являются неизменяемыми, то есть мы не можем изменить отдельный элемент строки:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first_name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">'y'</span>
<span class="o">...</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="s">'str'</span> <span class="nb">object</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">support</span> <span class="n">item</span> <span class="n">assignment</span>
</code></pre></div></div>

<p>И наконец мы можем брать подмножество (срез) элементов строки:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">email</span><span class="p">[:</span><span class="n">email</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">'@'</span><span class="p">)]</span>
<span class="s">'Dementiy'</span>
</code></pre></div></div>

<p>Синтаксис для создания срезов следующий: <code class="highlighter-rouge">sequence[start:stop:step]</code>, где:</p>
<ul>
  <li><code class="highlighter-rouge">sequence</code> - объект, который реализует Sequence протокол;</li>
  <li><code class="highlighter-rouge">start</code> - левая граница среза, может быть опущена, тогда принимается равной <script type="math/tex">0</script>;</li>
  <li><code class="highlighter-rouge">stop</code> - правая граница среза минус <script type="math/tex">1</script>, таким образом, правая граница не включается; может быть опущена, тогда принимается равной <code class="highlighter-rouge">len(sequence)</code>;</li>
  <li><code class="highlighter-rouge">step</code> - шаг, с которым перемещаемся по <code class="highlighter-rouge">sequence</code>, если не указан, то считается равным <script type="math/tex">1</script>.</li>
</ul>

<p>Мы рассмотрели лишь небольшую часть операций, которые можно выполнять над строками. Полный список операций вы всегда можете найти в документации.</p>

<h3 id="представление-строк">Представление строк</h3>

<p>Как уже было сказано, строки в Python являются Юникод строками. Для внтуреннего представления строк в Python, начиная с версии 3.3 (см. <a href="https://www.python.org/dev/peps/pep-0393/">PEP-393</a>), используются кодировки Latin-1 (1 байт на символ), UCS-2 (2 байта на символ) и UCS-4 (4 байта на символ). Упрощенно процесс определения кодировки следующий: когда необходимо создать строковый объект (тексты программ обычно в кодировке UTF-8), Python находит самый старший кодовый знак (code point) в строке и выбирает кодироку, в которой кодовый знак может быть представлен «как есть».</p>

<p>Строки представлены не одной структурой, а «иерархией» из трех <a href="https://github.com/python/cpython/blob/master/Include/unicodeobject.h#L197">структур</a>, не считая <code class="highlighter-rouge">PyObject</code>. Мы рассмотрим одну структуру - <code class="highlighter-rouge">PyASCIIObject</code>, которая содержит большую часть информации о строке, например, какая кодировка используется для хранения строки, длину строки (число кодовых знаков), состоит ли строка только из ASCII-символов, интернирована строка или нет и т.д.</p>

<p>Опишем структуру <code class="highlighter-rouge">PyASCIIObject</code> с помощью модуля <code class="highlighter-rouge">ctypes</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">ctypes</span>

<span class="k">class</span> <span class="nc">PyASCIIObject</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_refcnt"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_type"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"length"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"hash"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"interned"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"kind"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"compact"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ascii"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ready"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="s">'wstr'</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_wchar_p</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">get_string_kind</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">PyUnicodeObject</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">string</span><span class="p">))</span><span class="o">.</span><span class="n">kind</span>
</code></pre></div></div>

<p>Создадим несколько строковых объектов:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span> <span class="o">=</span> <span class="s">'Hello, world'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span>
<span class="s">'Hello, world'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">12</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">61</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_string_kind</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span> <span class="o">=</span> <span class="s">'Hello, 世界'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span>
<span class="s">'Hello, 世界'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">92</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_string_kind</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span> <span class="o">=</span> <span class="s">'Hello, </span><span class="se">\U0001F30D</span><span class="s">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span>
<span class="s">'Hello, 🌍'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">108</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_string_kind</span><span class="p">(</span><span class="n">greet</span><span class="p">)</span>
<span class="mi">4</span>
</code></pre></div></div>

<p>Обратите внимание, что хотя длина строк и становится меньше, но занимаемый размер наоборот растет, так как используются разные кодировки для внутреннего представления. Об этом важно помнить, особенно когда вы работаете с большими объемами текстов, так как один символ эмодзи может увеличить занимаемый размер строки в 4 раза.</p>

<p>Почему для внутреннего представления строк не используется UTF-8? Кодировка UTF-8 подразумевает, что может использоваться варьируемое число байт (от одного до четырех) для кодирования одного символа. UTF-8 является оптимальной кодировкой с точки зрения хранения строк (то есть кодировка эффективна по памяти), но при обращении к отдельным элементам строки (при индексировании), необходимо пройтись по всем символам строки пока мы не дойдем до нужного символа. При фиксированном размере такой проблемы не возникает, для перехода к нужной позиции символа достаточно индекс умножить на размер кодового знака (1, 2 или 4 в зависимости от используемой кодировки). Тем не менее есть <a href="http://utf8everywhere.org/">мнение</a>, что индексация это не проблема.</p>

<h3 id="интернирование-строк">Интернирование строк</h3>

<div class="admonition legend">
  <p class="first admonition-title"><strong>Замечание</strong></p>
  <p class="last">Дополнительно про интернирование можно почитать <a href="http://guilload.com/python-string-interning/">тут</a> и <a href="https://rushter.com/blog/python-strings-and-memory/">тут</a>.</p>
</div>

<p>Для экономии памяти в Python реализовано интернирование строк (string interning). Давайте рассмотрим такой пример, пусть у нас есть два строковых объекта с одинаковым содержимым:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"foo!"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"foo!"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="ow">is</span> <span class="n">s2</span>
<span class="bp">False</span>
</code></pre></div></div>

<p>Хотя содержимое строк совпадает это два разных объекта. С другой стороны:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="ow">is</span> <span class="n">s2</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>получим, что адреса <code class="highlighter-rouge">s1</code> и <code class="highlighter-rouge">s2</code> совпадают. Все строки длиной 0 или 1 интернированы, кроме того интернируются все строковые литералы, состоящие из символов латинского алфавита, цифр или нижнего подчеркивания, также интернируются имена переменных, функций, классов и т.д.</p>

<p>Ниже приведен упрощенный <a href="https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L15171">алгоритм интернирования</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">interned</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">intern</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">interned</span>
    
    <span class="k">if</span> <span class="n">string</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">TypeError</span>

    <span class="k">if</span> <span class="n">interned</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">interned</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">interned</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="n">interned</span><span class="p">[</span><span class="n">string</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span>
    <span class="k">return</span> <span class="n">string</span>
</code></pre></div></div>

<p>Если мы хотим интернировать строку, то следует воспользоваться функцией <code class="highlighter-rouge">intern</code> из модуля <code class="highlighter-rouge">sys</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="nb">intern</span><span class="p">(</span><span class="s">"foo!"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="nb">intern</span><span class="p">(</span><span class="s">"foo!"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s1</span> <span class="ow">is</span> <span class="n">s2</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>Использование интернирования строк гарантирует, что не будет создано двух одинаковых строковых объектов. Когда вы создаете второй объект с тем же значением, что и у существующего объекта, то вы получаете ссылку на уже существующий объект. Таким образом, интернирование строк позволяет экономить память и повышает скорость сравнения строк, путем сравнения их адресов (хешей), а не содержимого.</p>

<h3 id="списки">Списки</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span>
<span class="p">[]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="mf">90.4</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mf">72.3</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mf">84.5</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mf">64.9</span><span class="p">,</span> <span class="mi">61</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span>
<span class="p">[</span><span class="mf">90.4</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mf">72.3</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mf">84.5</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mf">64.9</span><span class="p">,</span> <span class="mi">61</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mf">90.4</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="mi">10</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">mean_score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mean_score</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span>
<span class="p">[</span><span class="mf">90.4</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mf">72.3</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mf">84.5</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mf">64.9</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">90</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">58</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">,</span> <span class="mi">79</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores</span>
<span class="p">[</span><span class="mf">90.4</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mf">72.3</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mf">84.5</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mf">64.9</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">,</span> <span class="mi">79</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">scores_copy</span> <span class="o">=</span> <span class="n">scores</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># == scores[:] == list(scores)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">scores_copy</span>
<span class="p">[</span><span class="mf">90.4</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mf">72.3</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mf">84.5</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mf">64.9</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mf">91.5</span><span class="p">,</span> <span class="mi">79</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="списки-как-динамические-массивы">Списки как динамические массивы</h3>

<p>Списки в Python являются обычными <a href="https://en.wikipedia.org/wiki/Dynamic_array">динамическими массивами</a> (вектор в C++) и обладают всеми их свойствами с точки зрения производительности: в частности, обращение к элементу по его индексу имеет сложность <script type="math/tex">O(1)</script>, а поиск элемента имеет сложность <script type="math/tex">O(N)</script>.</p>

<p>Списки в CPython определены с помощью следующей <a href="https://github.com/python/cpython/blob/master/Include/listobject.h#L23">структуры</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="cm">/* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">ob_item</span><span class="p">;</span>

    <span class="cm">/* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 &lt;= ob_size &lt;= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */</span>
    <span class="n">Py_ssize_t</span> <span class="n">allocated</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyListObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Где:</p>
<ul>
  <li><code class="highlighter-rouge">ob_item</code> - массив указателей на <code class="highlighter-rouge">PyObject</code>;</li>
  <li><code class="highlighter-rouge">allocated</code> - емкость списка (размер буффера), то есть сколько элементов можно поместить в массив <code class="highlighter-rouge">ob_item</code> до его увеличения, в то время как <code class="highlighter-rouge">ob_size</code> - текущее количество элементов в массиве.</li>
</ul>

<p><img src="/assets/images/lectures/lecture01-03.jpg" alt="" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* This over-allocates proportional to the list size, making room
 * for additional growth.  The over-allocation is mild, but is
 * enough to give linear-time amortized behavior over a long
 * sequence of appends() in the presence of a poorly-performing
 * system realloc().
 * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
 * Note: new_allocated won't overflow because the largest possible value
 *       is PY_SSIZE_T_MAX * (9 / 8) + 6 which always fits in a size_t.
 */</span>
<span class="n">new_allocated</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">newsize</span> <span class="o">+</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&lt;</span> <span class="mi">9</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div>

<p>Давайте посмотрим на процесс перераспределения памяти в действии с помощью модуля ctypes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ListStruct</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"ob_refcnt"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_type"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_size"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">),</span>
                <span class="p">(</span><span class="s">"ob_item"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">),</span>  <span class="c"># PyObject** pointer cast to long</span>
                <span class="p">(</span><span class="s">"allocated"</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ssize_t</span><span class="p">)]</span>
    
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s">"ListStruct(ob_size={self.ob_size}, allocated={self.allocated})"</span>
</code></pre></div></div>

<p>Создадим пустой список:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">ListStruct</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ls</span>
<span class="n">ListStruct</span><span class="p">(</span><span class="n">ob_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allocated</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>Пустой список имеет размер ноль и емкость ноль. Добавим один элемент:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ls</span>
<span class="n">ListStruct</span><span class="p">(</span><span class="n">ob_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allocated</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>Как мы видим и размер и емкость списка изменились в соответствии с правилом роста.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ls</span>
<span class="n">ListStruct</span><span class="p">(</span><span class="n">ob_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">allocated</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ls</span>
<span class="n">ListStruct</span><span class="p">(</span><span class="n">ob_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">allocated</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/lectures/lecture01-04.jpg" alt="" /></p>

<h3 id="кортежи">Кортежи</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">point</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">...</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="s">'tuple'</span> <span class="nb">object</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">support</span> <span class="n">item</span> <span class="n">assignment</span>
</code></pre></div></div>

<p>Кортежи vs списков:</p>
<ul>
  <li>С точки зрения внутреннего представления, кортежи также являются динамическими массивами.</li>
  <li>Кортежи занимают меньше места в памяти, так как имеют фиксированную длину.</li>
  <li>Кортежи неизменяемые (immutable) и могут быть выступать в качестве ключей словарей или элементов множеств.</li>
  <li>Кортежи обычно представляют абстрактные объекты, обладающие некоторой структурой.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">ob_item</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="cm">/* ob_item contains space for 'ob_size' elements.
     * Items must normally not be NULL, except during construction when
     * the tuple is not yet visible outside the function that builds it.
     */</span>
<span class="p">}</span> <span class="n">PyTupleObject</span><span class="p">;</span>
</code></pre></div></div>

<p>Вопрос:</p>
<ul>
  <li>Размер в байтах([1,1,1,1,1]) = Размер в байтах((1,1,1,1,1))?</li>
  <li>Размер в байтах([1,1,1,1,1]) &gt; Размер в байтах((1,1,1,1,1))?</li>
  <li>Размер в байтах([1,1,1,1,1]) &lt; Размер в байтах((1,1,1,1,1))?</li>
</ul>

<h3 id="словари">Словари</h3>

<p>Словари являются одной из самых важных и сложных структур в Python и мы с ними будем постоянно встречаться. В отличие от списков, которые являются упорядоченными последовательностями элементов произвольного типа, элементы словаря это неупорядоченные(?) последовательности пар <em>ключ:значение</em>.</p>

<p>Иногда словари называют <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">ассоциативными массивами</a>, иногда отображениями (имеется ввиду отображение множества ключей словаря в множество его значений).</p>

<p>Как и списки, словари имеют переменную длину, произвольную вложенность и могут хранить значения произвольных типов.</p>

<p>Создадим словарь с данными о населении ряда стран (ключами в таком словаре будут страны, а значениями - размер населения):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'India'</span><span class="p">:</span> <span class="mi">1326801576</span><span class="p">,</span>
    <span class="s">'Brazil'</span><span class="p">:</span> <span class="mi">209567920</span><span class="p">,</span>
    <span class="s">'China'</span><span class="p">:</span> <span class="mi">1382323332</span><span class="p">,</span>
    <span class="s">'Nigeria'</span><span class="p">:</span> <span class="mi">186987563</span><span class="p">,</span>
    <span class="s">'Bangladesh'</span><span class="p">:</span> <span class="mi">162910864</span><span class="p">,</span>
    <span class="s">'U.S.'</span><span class="p">:</span> <span class="mi">324118787</span><span class="p">,</span>
    <span class="s">'Russia'</span><span class="p">:</span> <span class="mi">143439832</span><span class="p">,</span>
    <span class="s">'Pakistan'</span><span class="p">:</span> <span class="mi">192826502</span><span class="p">,</span>
    <span class="s">'Mexico'</span><span class="p">:</span> <span class="mi">128632004</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Иногда у нас есть отдельно списки ключей и значений, из которых мы хотим создать словарь:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countries</span> <span class="o">=</span> <span class="p">[</span><span class="s">'India'</span><span class="p">,</span> <span class="s">'Brazil'</span><span class="p">,</span> <span class="s">'China'</span><span class="p">,</span> <span class="s">'Nigeria'</span><span class="p">,</span> <span class="s">'Bangladesh'</span><span class="p">,</span> <span class="s">'U.S.'</span><span class="p">,</span> <span class="s">'Russia'</span><span class="p">,</span> <span class="s">'Pakistan'</span><span class="p">,</span> <span class="s">'Mexico'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">populations</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1326801576</span><span class="p">,</span> <span class="mi">209567920</span><span class="p">,</span> <span class="mi">1382323332</span><span class="p">,</span> <span class="mi">186987563</span><span class="p">,</span> <span class="mi">162910864</span><span class="p">,</span> <span class="mi">324118787</span><span class="p">,</span> <span class="mi">143439832</span><span class="p">,</span> <span class="mi">192826502</span><span class="p">,</span> <span class="mi">128632004</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">countries</span><span class="p">,</span> <span class="n">populations</span><span class="p">))</span>
<span class="p">{</span><span class="s">'Bangladesh'</span><span class="p">:</span> <span class="mi">162910864</span><span class="p">,</span>
 <span class="s">'Brazil'</span><span class="p">:</span> <span class="mi">209567920</span><span class="p">,</span>
 <span class="s">'China'</span><span class="p">:</span> <span class="mi">1382323332</span><span class="p">,</span>
 <span class="s">'India'</span><span class="p">:</span> <span class="mi">1326801576</span><span class="p">,</span>
 <span class="s">'Mexico'</span><span class="p">:</span> <span class="mi">128632004</span><span class="p">,</span>
 <span class="s">'Nigeria'</span><span class="p">:</span> <span class="mi">186987563</span><span class="p">,</span>
 <span class="s">'Pakistan'</span><span class="p">:</span> <span class="mi">192826502</span><span class="p">,</span>
 <span class="s">'Russia'</span><span class="p">:</span> <span class="mi">143439832</span><span class="p">,</span>
 <span class="s">'U.S.'</span><span class="p">:</span> <span class="mi">324118787</span><span class="p">}</span>
</code></pre></div></div>

<p>Обращение к элементам словаря похоже на обращение к элементам последовательностей, только вместо индекса используется ключ:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="p">[</span><span class="s">'Russia'</span><span class="p">]</span>
<span class="mi">143439832</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="p">[</span><span class="s">'Russia'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">143439832</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="p">[</span><span class="s">'Russia'</span><span class="p">]</span>
<span class="mi">143439833</span>
</code></pre></div></div>

<p>Добавим новую пару:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="p">[</span><span class="s">'Japan'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">126323715</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span>
<span class="p">{</span><span class="s">'Bangladesh'</span><span class="p">:</span> <span class="mi">162910864</span><span class="p">,</span>
 <span class="s">'Brazil'</span><span class="p">:</span> <span class="mi">209567920</span><span class="p">,</span>
 <span class="s">'China'</span><span class="p">:</span> <span class="mi">1382323332</span><span class="p">,</span>
 <span class="s">'India'</span><span class="p">:</span> <span class="mi">1326801576</span><span class="p">,</span>
 <span class="s">'Japan'</span><span class="p">:</span> <span class="mi">126323715</span><span class="p">,</span>
 <span class="s">'Mexico'</span><span class="p">:</span> <span class="mi">128632004</span><span class="p">,</span>
 <span class="s">'Nigeria'</span><span class="p">:</span> <span class="mi">186987563</span><span class="p">,</span>
 <span class="s">'Pakistan'</span><span class="p">:</span> <span class="mi">192826502</span><span class="p">,</span>
 <span class="s">'Russia'</span><span class="p">:</span> <span class="mi">143439833</span><span class="p">,</span>
 <span class="s">'U.S.'</span><span class="p">:</span> <span class="mi">324118787</span><span class="p">}</span>
</code></pre></div></div>

<p>При попытке извлечь значение с несуществующим ключом, генерируется
исключение «Ключа не существует»:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="p">[</span><span class="s">'Poland'</span><span class="p">]</span>
<span class="o">...</span>
<span class="nb">KeyError</span><span class="p">:</span> <span class="s">'Poland'</span>
</code></pre></div></div>

<p>С помощью оператора <code class="highlighter-rouge">in</code> можно проверить существует ли ключ в словаре. Оператор <code class="highlighter-rouge">in</code> работает со всеми контейнерами (строки, списки, кортежи, словари, множества), но для последовательностей (строки, списки, кортежи) эта операция является медленной:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="s">"Russia"</span> <span class="ow">in</span> <span class="n">population_by_countries</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s">"Poland"</span> <span class="ow">in</span> <span class="n">population_by_countries</span>
<span class="bp">False</span>
</code></pre></div></div>

<p>Можно воспользоваться методом <code class="highlighter-rouge">get</code>, опционально указав значение, которое будет возвращено, если ключ не был найден:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'Poland'</span><span class="p">)</span> <span class="c"># None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'Poland'</span><span class="p">,</span> <span class="s">'NA'</span><span class="p">)</span>
<span class="s">'NA'</span>
</code></pre></div></div>

<p>Иногда нужно получить отдельно «список» ключей, значенией или кортежей (ключ, значение):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="n">dict_keys</span><span class="p">([</span><span class="s">'India'</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="s">'Japan'</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="n">dict_values</span><span class="p">([</span><span class="mi">1326801576</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">126323715</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">population_by_countries</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="n">dict_items</span><span class="p">([(</span><span class="s">'India'</span><span class="p">,</span> <span class="mi">1326801576</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="s">'Japan'</span><span class="p">,</span> <span class="mi">126323715</span><span class="p">)])</span>
</code></pre></div></div>

<p>Вы не можете упорядочить словарь по ключам или значениям, но можете получить список кортежей и упорядочить его:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population_by_countries</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">[(</span><span class="s">'China'</span><span class="p">,</span> <span class="mi">1382323332</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'India'</span><span class="p">,</span> <span class="mi">1326801576</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'U.S.'</span><span class="p">,</span> <span class="mi">324118787</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Brazil'</span><span class="p">,</span> <span class="mi">209567920</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Pakistan'</span><span class="p">,</span> <span class="mi">192826502</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Nigeria'</span><span class="p">,</span> <span class="mi">186987563</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Bangladesh'</span><span class="p">,</span> <span class="mi">162910864</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Russia'</span><span class="p">,</span> <span class="mi">143439833</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Mexico'</span><span class="p">,</span> <span class="mi">128632004</span><span class="p">),</span>
 <span class="p">(</span><span class="s">'Japan'</span><span class="p">,</span> <span class="mi">126323715</span><span class="p">)]</span>
</code></pre></div></div>

<p>Зачастую словари используются для представления куда более сложных структур, например:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">requests</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">'https://api.openweathermap.org/data/2.5/weather?q=Saint Petersburg&amp;units=metric&amp;APPID=a46b3bb83f9e16e2ee203e9ecfca99f8'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
<span class="p">{</span><span class="s">'base'</span><span class="p">:</span> <span class="s">'stations'</span><span class="p">,</span>
 <span class="s">'clouds'</span><span class="p">:</span> <span class="p">{</span><span class="s">'all'</span><span class="p">:</span> <span class="mi">75</span><span class="p">},</span>
 <span class="s">'cod'</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
 <span class="s">'coord'</span><span class="p">:</span> <span class="p">{</span><span class="s">'lat'</span><span class="p">:</span> <span class="mf">59.94</span><span class="p">,</span> <span class="s">'lon'</span><span class="p">:</span> <span class="mf">30.32</span><span class="p">},</span>
 <span class="s">'dt'</span><span class="p">:</span> <span class="mi">1519380000</span><span class="p">,</span>
 <span class="s">'id'</span><span class="p">:</span> <span class="mi">498817</span><span class="p">,</span>
 <span class="s">'main'</span><span class="p">:</span> <span class="p">{</span><span class="s">'humidity'</span><span class="p">:</span> <span class="mi">85</span><span class="p">,</span>
          <span class="s">'pressure'</span><span class="p">:</span> <span class="mi">1027</span><span class="p">,</span>
          <span class="s">'temp'</span><span class="p">:</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>
          <span class="s">'temp_max'</span><span class="p">:</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>
          <span class="s">'temp_min'</span><span class="p">:</span> <span class="o">-</span><span class="mi">11</span><span class="p">},</span>
 <span class="s">'name'</span><span class="p">:</span> <span class="s">'Saint Petersburg'</span><span class="p">,</span>
 <span class="s">'sys'</span><span class="p">:</span> <span class="p">{</span><span class="s">'country'</span><span class="p">:</span> <span class="s">'RU'</span><span class="p">,</span>
         <span class="s">'id'</span><span class="p">:</span> <span class="mi">7267</span><span class="p">,</span>
         <span class="s">'message'</span><span class="p">:</span> <span class="mf">0.0041</span><span class="p">,</span>
         <span class="s">'sunrise'</span><span class="p">:</span> <span class="mi">1519362815</span><span class="p">,</span>
         <span class="s">'sunset'</span><span class="p">:</span> <span class="mi">1519398694</span><span class="p">,</span>
         <span class="s">'type'</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
 <span class="s">'visibility'</span><span class="p">:</span> <span class="mi">9000</span><span class="p">,</span>
 <span class="s">'weather'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'description'</span><span class="p">:</span> <span class="s">'light snow'</span><span class="p">,</span>
              <span class="s">'icon'</span><span class="p">:</span> <span class="s">'13d'</span><span class="p">,</span>
              <span class="s">'id'</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span>
              <span class="s">'main'</span><span class="p">:</span> <span class="s">'Snow'</span><span class="p">}],</span>
 <span class="s">'wind'</span><span class="p">:</span> <span class="p">{</span><span class="s">'deg'</span><span class="p">:</span> <span class="mi">280</span><span class="p">,</span> <span class="s">'speed'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
</code></pre></div></div>

<h3 id="хеширование">Хеширование</h3>

<p>Мы не будем рассматривать внутреннее представление словарей, так как они устроены значительно сложнее чем объекты, которые мы рассматривали ранее. Для интересующихся можно посмотреть выступления <a href="https://www.youtube.com/watch?v=p33CVV29OG8">Raymond Hettinger</a> и <a href="https://www.youtube.com/watch?v=66P5FMkWoVU">Brandon Rhodes</a> о работе словарей, или почитать исчерпывающую презентацию <a href="https://www.slideshare.net/delimitry/python-dict-66233023">Дмитрия Алимова</a> об эволюции словарей, начиная с Python 2.x.</p>

<p>Тем не менее следует знать, что ключами словарей могут быть только хешируемые объекты, то есть те объекты, для которых определена хеш-функция (обычно это числа, строки и кортежи).</p>

<p>Существует множество видов хеш-функций и для того, чтобы дать вам интуицию того, что из себя представляет хеш-функция, рассмотрим пример слабой хеш-функции и ее использования:</p>

<iframe width="800" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20my_hash%28astring%29%3A%0A%20%20%20%20h%20%3D%200%0A%20%20%20%20for%20pos%20in%20range%28len%28astring%29%29%3A%0A%20%20%20%20%20%20%20%20h%20%2B%3D%20pos%20*%20ord%28astring%5Bpos%5D%29%0A%20%20%20%20return%20h%0A%20%20%20%20%0AL%20%3D%20%5BNone,%20None,%20None,%20None,%20None%5D%0A%0Aindex%20%3D%20my_hash%28%22cat%22%29%20%25%20len%28L%29%20-%201%0AL%5Bindex%5D%20%3D%20%22cat%22%0A%0Aindex%20%3D%20my_hash%28%22dog%22%29%20%25%20len%28L%29%20-%201%0AL%5Bindex%5D%20%3D%20%22dog%22&amp;codeDivHeight=400&amp;codeDivWidth=350&amp;cumulative=false&amp;curInstr=0&amp;heapPrimitives=false&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false"> </iframe>

<p>Фактически мы получили очень наивную реализацию <a href="https://en.wikipedia.org/wiki/Hash_table">хеш-таблицы</a> (словаря).</p>

<h3 id="множества">Множества</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">a_set</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a_set</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="bp">True</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">a_set</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">6</span> <span class="ow">in</span> <span class="n">a_set</span>
<span class="bp">False</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="o">&amp;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

  </div>

  
    <div class="post-comments" itemprop="comment">
      
<div id="disqus_thread"></div>
<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://dementiy.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    </div>
  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dementiy.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
